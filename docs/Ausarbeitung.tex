\documentclass[11pt]{article}

% Document structure
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}

\usepackage{graphicx}

% Für mathbb
\usepackage{amssymb}
% Für in mathmode embedded text
\usepackage{amsmath}

% Deutsche Sprache
\usepackage[utf8]{inputenc} % this is needed for umlauts
\usepackage[ngerman]{babel} % this is needed for umlauts und damit figuren Abbildung heißen
\usepackage[T1]{fontenc}    % this is needed for correct output of umlauts in pdf


% \subsection{References for the prototype}
% 
% Wenn wir irgendwas referenzieren wollen, vor allem andere Algorithmen. Sollten wir die Quelle in Quellen.bib eintragen und mit \cite{Quelle} zitieren
% Das System beruht auf Bibtex, das muss also runtergeladen werden, ist aber in latexmk enthalten
% 
% \cite{berger_rompel}

\title{Analyse und Verbesserung bestehender Algorithmen zur Lösung des Graphfärbeproblems}
\author{Menschen} % TODO

\renewcommand*\contentsname{Inhaltsverzeichnis} % Hier kann der Name des Inhaltsverzeichnisses verändert werden
\newcommand{\degeneracy}{\text{degeneracy}}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Kurzfassung} % Was haben wir gemacht, ein Absatz
\section{Begriffsklärung} % TODO, laufend aktualisieren, wenn ein neuer Begriff verwendet wurde
\begin{itemize}[noitemsep, left=0pt]
\item Wir behandeln in dieser Ausarbeitung ausschließlich ungerichtete \\Graphen.
Diese seien folgendermaßen definiert:\\
Ein Graph $G$ ist ein Tupel $G=(V,E)$, wobei $V=\{v_1,v_2,...,v_n\}$ und $E\subseteq \{(u,v)\in V\times V \mid u\neq v\}$
\item Wir notieren einen Subgraphen $G'$ als 
$G'=G[V']$,
wobei $G=(V,E)$ ein Graph ist und $V'\subseteq V(G)$.
Es gilt $G[V']=(V',E')$ mit $E'=\{(u,v)\in E\mid u\in V'\land v\in V'\}$.
\item Eine Färbung eines Graphen $G=(V,E)$ sei eine Zuordnung $F: V\mapsto \mathbb{N}$. Eine Färbung kann sich zur Laufzeit eines Algorithmusses ändern.
Wenn wir einen Knoten $v$ \grqq färben\grqq\ so ändern wir eigentlich den Wert von $F(v)$.
\item Der Grad $\deg_G(v)$ eines Knoten $v$ ist die Anzahl an von ihm ausgehenden Kanten $|\{(v_1,v_2)\in E(G) | v_1=v\lor v_2=v\}|$
Wir definieren $\delta G=\min\{\deg_G(v)|v\in V(G)\}$
\end{itemize}
\section{Etablierte Algorithmen}
\subsection{Greedy Algorithmen}
Sei $G=(V,E)$ ein zu färbender Graph.
Wir bestimmen zunächst eine Reihenfolge der Knoten in $V$, wobei $v_i$ der $i$-te Knoten ist.
Wir nehmen zunächst an, dass die Reihenfolge keine speziellen Eigenschaften hat.
Der Greedy Algorithmus geht nun folgendermaßen vor:
\begin{itemize}
\item[1.] Sei $i=1$
\item[2.] $F(v_i) \leftarrow \min\{n\in\mathbb{N}|\nexists j < i: F(v_j)=n\land \{v_i, v_j\}\in E\}$
\item[3.] ist $i<|V|$, so $i\leftarrow i+1$ und gehe zurück zu Schritt 1 
\end{itemize}

Je nachdem wie wir die Reihenfolge bilden, erhalten wir unterschiedliche Varianten des Greedy-Algorithmusses.
Wählen wir eine Reihenfolge ohne spezielle Eigenschaften (in der Praxis die Definitionsreihenfolge),
so bezeichnen wir dies als den Standard-greedy, bzw. nur greedy.

Erstellen wir eine Reihenfolge $v_1,v_2,\ldots,v_n$, wobei $v_i$ ein Knoten kleinsten Grades im Graphen $G[\{v_1,\ldots,v_i\}]$ ist, so bezeichnen wir den Algorithmus als greedy-smallest-degree-last oder kurz greedy-max.
Sei $v_i$ analog ein Knoten größten Grades im Graphen $G[\{v_1,\ldots,v_i\}]$, so reden wir von greedy-largest-degree-last oder greedy-min.

Sei die degeneracy von $G$ definiert als\\
$\degeneracy(G)=\max\{\delta G[V']|V'\subseteq V\}$.\\

\subsection{Wigdersons Algorithmen} % TODO

Bei den zwei Algorithmen von Wigderson handelt es sich eigentlich um einen Algorithmus und einen Spezialfall dessen.

\subsubsection{Wigdersons erster Algorithmus}

Der erste Algorithmus, der Spezialfall, braucht einen Graphen, der garantiert mit $3$ Farben färbbar ist.
Er färbt diesen Graphen in $O(\sqrt{n})$ Farben, wobei $n$ die Anzahl der Knoten im Graphen ist. $O(\sqrt{n})$ bedeutet hier,
dass im schlimmsten Fall $\sqrt{n}$ viele Farben (aufgerundet) verwendet werden, es können aber auch weniger sein. \\
%Bei dem Satz bin ich mir nicht sicher, ob der sein muss oder ob O-Notation einfach in der Begriffserklärung reinkommt
Dieser Algorithmus nutzt aus, dass sich ein $2-$färbbarer Graph immer und mit wenig Aufwand perfekt färben lässt. %Citation needed
Um einen auf jeden Fall $2-$färbbaren Subgraphen zu erhalten, den man färben kann, wird nun zuerst ein Knoten des
Ausgangsgraphen gewählt. Hierbei wird der Knoten mit höchstem Grad ausgewählt. Nun wird dessen Nachbarschaft %Begriffserklärung?
betrachtet. Da der ausgewählte Knoten eine Farbe (o.B.d.A. nennen wir die Farbe $3$) haben muss, die in seiner Nachbarschaft nicht vorkommen kann, muss diese Nachbarschaft
$2-$färbbar sein, da der gesamte Graph $3-$färbbar ist. Also färbt man die Nachbarschaft in $2$ (o.B.d.A. nennen wir diese Farben $1$ und $2$) und entfernt sowohl den Knoten
als auch die Nachbarschaft für die restliche Betrachtung aus dem Ausgangsgraphen aus und kehrt zum ersten Schritt zurück, dem Wählen
des nächsten Knotens mit höchstem Grad. Die Nachbarschaft dessen könnte aber im Ausgangsgraphen mit nun schon
gefärbten und entfernten Knoten benachbart sein, weswegen als Farben für diesen Durchlauf eine ungenutzte Farbe (o.B.d.A. $4$) verwendet wird, sowie die Farbe, die ausgewählte Knoten des letzten Durchlaufs hatte ($3$). \\
Der neue ausgewählte Knoten erhält ebenfalls eine neue Farbe (o.B.d.A. $5$), die dann im nächsten Durchlauf weiter verwendet werden kann.
Dies führt man nun fort, bis es sich mehr lohnt, den Graphen per Greedy-Algorithmus fertig zu färben. 
Dieser Punkt ist erreicht, wenn der höchste Knotengrad im verbleibenden Graphen unter die Grenze von $\sqrt{n}$ fällt. \\
Um nun zu zeigen, wie viele Farben dieser Algorithmus verwendet und welche Komplexität dieser Algorithmus hat, kann man nun rechnen. \\
Für die Anzahl der Farben gilt: Jeder der oben beschriebenen Durchläufe verbraucht $2$ neue Farben und färbt mindestens $\sqrt{n}+1$ Knoten, also $O(\sqrt{n})$.
Deswegen kann es nur weniger als maximal $\sqrt{n}$ Durchläufe geben, bis alle Knoten gefärbt sind oder die Durchläufe abgebrochen werden, weil der maximale Grad zu niedrig wird.
Also verwendet dieser Teil des Algorithmus höchstens $2*\sqrt{n}$ Farben. Da nur noch Knoten mit höchstens Grad $\sqrt{n}-1$ übrig sind, kann der Greedy-Algorithmus
den Rest des Graphen immer in $\sqrt{n}$ Farben färben. So erhält man ein Ergebnis von maximal $3*\sqrt{n}$ Farben. \\
Für die Komplexität des Algorithmus gilt: Jeder der oben beschriebenen Durchläufe iteriert über alle Knoten, um den mit dem größten Grad zu finden $(O(n))$,
noch einmal, um die Nachbarschaft vom Knoten zu ermitteln $(auch \space O(n))$ %oder auch nicht, weil sich das in der NetworkX Dokumentation nicht herausfinden lässt aaaaaaaaaaaaaaaah
und hat wie in der Rechnung zur Farbanzahl schon gezeigt $\sqrt{n}$ Durchläufe maximal $O(\sqrt{n})$.
Dieser Teil des Algorithmus ist also in der Komplexitätsklasse $O(n*\sqrt{n})$. \\
Der Greedy-Algorithmus hat die Komplexität von $O(n+m)$ oder $O(n^2)$, je nachdem wie NetworkX im Hintergrund die Adjacency abspeichert... %Bro ist das dumm ey. Da steht nicht genau, wie der Befehl G.neighbors funktioniert, den wir die ganze Zeit verwendet haben.
wobei das $m$ für die Anzahl der Kanten steht. Laut Wigderson selbst sollte die Komplexität des Algorithmus $O(3*(n+m))$ sein. Vielleicht wenn der obere Teil des Algorithmus nicht $O(n*\sqrt{n})$ ist sondern $O(n)$. Aber da bin ich mir nicht ganz sicher gerade.

\subsubsection{Wigdersons zweiter Algorithmus}

Der zweite Algorithmus ist eine verallgemeinerte Variante, die funktioniert, wenn die Färbungszahl des gegebenen Graphen bekannt ist.
Er benutzt dabei $k*n^{1-\frac{1}{k-1}}$ Farben maximal, wobei $k$ die Färbungszahl und $n$ die Anzahl der Knoten ist. \\
Der Algorithmus verwendet die gleiche Eigenschaft, dass ein $2-$färbbarer Graph simpel zu färben ist.
Dazu wird wie im obigen Algorithmus beschrieben, der Knoten mit höchstem Grad ausgewählt und auf dessen Nachbarschaft geschaut. Da die Färbungszahl hier wahrscheinlich noch nicht $3$ beträgt, lässt sich diese Nachbarschaft nicht mit $2$ Farben färben, aber dafür mit $k-1$ Farben. Sollte dies immer noch nicht gleich $3$ sein, so wird in dieser Nachbarschaft erneut der Knoten mit höchstem Grad ausgesucht und dann in diesem Subgraphen dessen Nachbarschaft angeschaut. Sie kann nun sicher mit $k-2$ Farben gefärbt werden. Sollte dies nun gleich $3$ ergeben, wird noch einmal so vorgegangen wie im ersten Algorithmus und so dieser Subgraph gefärbt. \\
Auch wie im anderen Algorithmus gibt es ein Abbruchkriterium, wann sich stattdessen der Greedy-Ansatz mehr lohnt. Dieses ist erreicht, wenn der amximale Grad im betrachteten (Sub-)Graphen kleiner ist als $k*n^{\frac{1}{k-1}}$, die gleiche Gleichung wie die Maximalzahl an Farben im Graphen.
Dieser Algorithmus hat laut Wigderson eine Laufzeitkomplexitätsklasse von $O(k(n+m))$, wobei $k$ die Färbungszahl, $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten ist.

\subsection{Johnsons Algorithmus} % TODO
\subsection{Berger Rompel Algorithmus} % TODO

Der Algorithmus von Berger Rompel
baut auf der Idee von Johnsons und Wigderson auf
und verbessert diese um einige Punkte.
\cite{berger_rompel}

\section{Ergebnisse zu den etablierten Algorithmen} % TODO
\section{Eigens produzierte Algorithmen} % TODO
\subsection{Merging Algorithmus}
Bei der Überlegung, welche Ansätze zur Entwicklung eines eigenen Solvers sinnvoll wären,
kam die Idee auf, das bekannte Konzept des Divide-and-Conquer zu nutzen.\\
Idee dabei ist, die Färbung für einen Graphen $G$ zu finden, 
indem zunächst ein Schnitt $S\subseteq V(G)$ gebildet wird 
und der Algorithmus rekursiv auf die ind. Subgraphen 
$G[S]$ und $G[V(G)\setminus] S$ angewendet wird. 
Kleine Graphen können dann sogar optimal gelöst werden. 
Problem jedoch ist, dass an den Kanten, 
welche in keiner der ind. Subgraphen enthalten sind,
Konflikte entstehen können. Diese müssen durch eine besondere Operation entfernt werden, 
welche wir nun als Vereinigung bezeichnen.\par

Wir können nun in der Wahl des Schnittes und dem Algorithmus zur Vereinigung variieren.\\
In unserer Arbeit haben wir 2 Varianten analysiert. Wir nennen sie merge-trivial und merge-recolor.
Dabei nutzen beide folgenden Algorithmus um einen Schnitt $S\subseteq V(G)$ zu bilden:
\begin{itemize}
\item[1.] Führe den folgenden Algorithmus für alle Zusammenhangskomponenten von $G$ getrennt aus
\item[2.] Wähle einen zufälligen Knoten $u\in V(G)$
\item[3.] Berechne zu jedem Knoten in $n\in V(G)$ die Distanz $d_u(n)$ zu $u$ mithilfe einer Breitensuche
\item[4.] Wähle einen Knoten mit maximaler Distanz zu $u$, bezeichne ihn als $v$
\item[5.] Berechne zu jedem Knoten in $n\in V(G)$ auch die Distanz $d_v(n)$ zu $v$
\item[6.] Für jeden Knoten $n\in V(G)$: Füge $n$ zu $S$ hinzu, falls $d_u(n)<d_v(n)$; Falls $d_u(n)=d_v(n)$ füge $n$ mit einer Wahrscheinlichkeit von 50\% zu $S$ hinzu
\end{itemize}

Der merge-trivial Algorithmus nutzt eine triviale Vereinigungsstrategie. 
Wenn zur Färbung von $G[S]$ die Farben $\{1,2,...,i\}$ benutzt wurden, 
werden für die Färbung von $G[V(G)\setminus S]$ nur Farben $\{i+1,i+2,...,k\}$ verwendet.\\

Der Algorithmus liefert vergleichsweise schlechte Ergebnisse, 
da lediglich im Basisfall eine Verbesserung gegenüber der trivialen Färbung erziehlt werden kann.
Angenommen der Algorithmus färbt ab einer Anzahl von $m$ oder weniger Knoten optimal
und $k$ sei die optimale Färbungszahl von $G$, so kommt man auf eine untere Grenze von 
$k*2^{log_2(|V(G)|)-log_2(m)}$ bzw. $k*\frac{|V(G)|}{m}$ Farben, vorausgesetzt, dass $m\geq k$.\par

Der merge-recolor Algorithmus nutzt stattdessen einen aufwendigeren Vereinigungsalgorithmus:\\
Wir bezeichnen hierbei den Subgraphen $G[S]$ als $A$ und den Subgraphen $G[V(G)\setminus S]$ als $B$
\begin{itemize}
\item[1.] Benenne Farben in $B$ um, bis keine Farbe sowohl in $A$ als auch in $B$ verwendet wird.
\item[2.] Konstruiere einen Graphen $G'=(V',E')$, $V'$ sei die Menger verwendeter Farben
\item[3.] $E'$ sei die Menge aller Paare aus Farben, welche nicht durch eine Kante in $G$ miteinander verbunden sind. \\Hierzu sollte nur die Menge der Kanten $E(G)\setminus (E(A)\cup E(B))$ betrachtet werden.
\item[4.] Berechne ein maximales Matching $M$ auf $G'$
\item[5.] Für jede Kante $(u,v)\in M$, färbe alle Knoten der Farbe $u$, stattdessen mit der Farbe $v$.
\end{itemize}

Zusätzlich behandeln wir eine Alternative Version, merge-recolor-bf, welche im Basisfall tatsächlich eine optimale Lösung (hier per \textbf{b}rute-\textbf{f}orce) findet.
Der Standardfall merge-recolor greift lediglich auf den greedy-max Algorithmus zu.

\begin{figure}
  \includegraphics[width=\linewidth]{diagrams/merger_pic1.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit Greedy bei Graphen mit 50 Knoten}
  \label{fig:merge1}
\end{figure}

Im Vergleich zu den besseren Varianten der Greedy Algorithmen schneiden die Merging Algorithmen unterschiedlich ab. Wie in Abbildung \ref{fig:merge1} zu sehen ist, scheidet der merge-trivial Algorithmus sehr schlecht ab.
Vielversprechender sind die merge-recolor und merge-recolor-bf Algorithmen, welche bessere Ergebnisse als merge-trivial erzielen können, jedoch immernoch schlechter sind als greedy-max. Untereinander unterscheiden sich die Ergebnisse der bisherigen merge-recolor Varianten kaum.

\begin{figure}
  \includegraphics[width=\linewidth]{diagrams/merger_pic2.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit Greedy bei Graphen mit 300 Knoten}
  \label{fig:merge2}
\end{figure}

Die Unterschiede werden bei Graphen mit 300 Knoten noch deutlicher (siehe Abb. \ref{fig:merge2}).
Um die Ergebnisse des merge Algorithmusses zu verbessern haben wir im Weiteren versucht, 
die Farben, welche bei der Vereinigung nicht zusammengefasst werden können,
zu entfärben und ihre Knoten mittels des in greedy-color-swaps verwendeten Verfahren neu zu färben.
Praktisch heißt dies, dass wir den Vereinigungsschritt um eine Anwendung von color-swaps erweitern.
Dies tun wir wie folgt:

\begin{itemize}
\item[1.] Benenne Farben in $B$ um, bis keine Farbe sowohl in $A$ als auch in $B$ verwendet wird.
\item[2.] Konstruiere einen Graphen $G'=(V',E')$, $V'$ sei die Menger verwendeter Farben
\item[3.] $E'$ sei die Menge aller Paare aus Farben, welche nicht durch eine Kante in $G$ miteinander verbunden sind. \\Hierzu sollte nur die Menge der Kanten $E(G)\setminus (E(A)\cup E(B))$ betrachtet werden.
\item[4.] Berechne ein maximales Matching $M$ auf $G'$
\item[5.] Für jede Kante $(u,v)\in M$, färbe alle Knoten der Farbe $u$, stattdessen mit der Farbe $v$.
\item[6.] Für jeden Knoten $u\in M$, wobei $\neg \exists e\in M : u\in e$, entfärbe alle Knoten mit Farbe $u$.
\item[7.] Wähle einen ungefärbten Knoten $x$. Existiert keiner, so springe zu 10.
\item[8.] Finde 2 Knoten $y,z$ aus der Nachbarschaft von $x$, diese seien mit den Farben $F(y)$ und $F(z)$ gefärbt, wobei $F(y)\neq F(z)$.
Außerdem lasse sich die Zusammenhangskomponente aus Knoten $\{v\in G | F(v)=F(y) \lor F(v)=F(z)\}$ um $z$ so umfärben, dass im Endeffekt $F(y)=F(z)$ gilt.
\item[9.] Lässt sich 8. durchführen, so Färbe $z$ um und gebe $x$ die alte Farbe von $z$, andernfalls gebe $x$ die kleinste, nicht in seiner Nachbarschaft verwendete, Farbe.
\item[10.] Solange noch ungefärbte Knoten existieren gehe zurück zu 7.
\end{itemize}

Diesen Algorithmus bezeichnen wir nun als greedy-recolor-color-swaps.
Er weißt deutlich bessere Ergebnisse auf (siehe Abb. \ref{fig:merge3}), jedoch werden von greedy-color-swaps dennoch bessere Ergebnisse erzielt.
\begin{figure}
  \includegraphics[width=\linewidth]{diagrams/merger_pic3.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit dem merge-recolor-color-swaps Ansatz}
  \label{fig:merge3}
\end{figure}
Besonders fällt dies auf, wenn wir statt den verwendeten Farben die Laufzeit betrachten. Die verwendeten Farben liegen auf ähnlichem Level,
aber die Laufzeit ist bei dem merge-recolor-color-swaps Verfahren deutlich schlechter (siehe Abb. \ref{fig:merge4}).\\
\begin{figure}
  \includegraphics[width=\linewidth]{diagrams/merger_pic4.png}
  \caption{Vergleich der Laufzeit zwischen greedy und merge mit color swaps}
  \label{fig:merge4}
\end{figure}
Merge-recolor, welches von Farben her eher mit greedy-max vergleichbar ist, hatte auf unseren Testdaten ebenfalls eine schlechtere Laufzeit (siehe Abb.\ref{fig:merge5}).
\begin{figure}
  \includegraphics[width=\linewidth]{diagrams/merger_pic5.png}
  \caption{Vergleich der Laufzeit zwischen greedy und merge ohne color swaps}
  \label{fig:merge5}
\end{figure}

Wollte man den merge Ansatz weiter verfolgen wollen, bleibt zu analysieren, warum der bisherige Algorithmus mehr Farben braucht als greedy.
Ein essenzieller Angriffspunkt bleibt die Wahl des Schnittes die wir zunächst vorgestellt haben und nicht variiert haben.
Wir können diese Wahl so abwandeln, dass die Möglichkeit für Konflikte zwischen Farben pro Vereinigung minimiert wird.
Ein Ansatz hierfür den Knoten mit der geringsten Nachbarschaft abzutrennen und den Algorithmus auf den Knoten sowie den Restgraphen anzuwenden.
Dies gleicht jedoch weitesgehend dem Verhalten von greedy-min.

Wir beenden diesen Ansatz mit dem Fazit, dass sich mit diesem Verfahren für uns keine großen Fortschritte ergeben,
da die Abweichung zu bisherigen Algorithmen hier eher einen Nachteil dargestellt hat.
Stattdessen wollen wir mit einem Verfahren weitermachen, welches bisherige Algorithmen veruscht zu erweitern, anstatt sie zu ersetzen.

\subsection{Make-Better Algorithmus}

Der Ansatz für diesen Algorithmus war es, eine schon fertige Färbung eines Graphen zu nehmen und versuche, diese zu verbessern. \\
Um dies durchzuführen, werden die Knoten als Farbgruppen betrachtet. Dann schaut man in jeder Farbgruppe, ob man nicht die einzelnen Knoten in eine andere Farbe umfärben kann. \\
Das kann man immer, wenn ein Knoten keine Verbindung zu mindestens einer anderen Farbe hat. Findet man so eine Farbgruppe, aus der man alle Knoten umfärben kann, 
macht der Algorithmus dies und entfernt somit eine ganze Farbe aus der Färbung des Graphen. \\
Dies kann man so lange wiederholen, bis sich keine Farbe mehr entfernen lässt.

\section{Ergebnisse zu den eigenen Algorithmen} % TODO
\section{Zusammenfassung und Fazit} % TODO

\bibliographystyle{plain}
\bibliography{Quellen}
\end{document}
