\documentclass[11pt]{article}

% Document structure
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}

\usepackage{graphicx}

% Für mathbb
\usepackage{amssymb}
% Für in mathmode embedded text
\usepackage{amsmath}

% Deutsche Sprache
\usepackage[utf8]{inputenc} % this is needed for umlauts
\usepackage[ngerman]{babel} % this is needed for umlauts und damit figuren Abbildung heißen
\usepackage[T1]{fontenc}    % this is needed for correct output of umlauts in pdf


% \subsection{References for the prototype}
% 
% Wenn wir irgendwas referenzieren wollen, vor allem andere Algorithmen. Sollten wir die Quelle in Quellen.bib eintragen und mit \cite{Quelle} zitieren
% Das System beruht auf Bibtex, das muss also runtergeladen werden, ist aber in latexmk enthalten
% 
% \cite{berger_rompel}

\title{Analyse und Verbesserung bestehender Algorithmen zur Lösung des Graphfärbeproblems}
\author{Menschen} % TODO

\renewcommand*\contentsname{Inhaltsverzeichnis} % Hier kann der Name des Inhaltsverzeichnisses verändert werden
\newcommand{\degeneracy}{\text{degeneracy}}

\begin{document}
% Größe von Bildern
\newlength{\stdwidth}
\setlength{\stdwidth}{0.6\linewidth}
\maketitle

\tableofcontents
\newpage

\section{Kurzfassung} % Was haben wir gemacht, ein Absatz

In dieser Ausarbeitung werden die Ergebnisse unseres Semesterprojekts\\
\grqq Schnelle Algorithmen für schwere Probleme\grqq\ mit dem Fokus auf
Graphenfärbungsalgorithmen zusammengefasst. \\ 
Das exakte Färben von Graphen mit möglichst wenig Farben ist mit relativ simplen Inputs bereits ein NP-schweres Problem, weswegen es bereits einige Ansätze gibt,
möglichst gute Färbungen in vergleichbar kurzer Zeit zu erzeugen. Einige dieser Ansätze wurden von uns implementiert und auf die $2$ Faktoren 
Laufzeit und die Anzahl der genutzten Farben untersucht.
Desweiteren haben wir drei eigenen Algorythmen entwickelt und diese auf die selben Eigenschaften untersucht. \\
Unsere Implementierungen sind in der Sprache Python und nutzen die Bibliothek NetworkX.

\section{Begriffsklärung} % TODO, laufend aktualisieren, wenn ein neuer Begriff verwendet wurde
\begin{itemize}[noitemsep, left=0pt]
\item Wir behandeln in dieser Ausarbeitung ausschließlich ungerichtete \\Graphen.
Diese seien folgendermaßen definiert:\\
Ein Graph $G$ ist ein Tupel $G=(V,E)$, wobei $V=\{v_1,v_2,...,v_n\}$ und $E\subseteq \{(u,v)\in V\times V \mid u\neq v\}$
\item Wir notieren einen Subgraphen $G'$ als 
$G'=G[V']$,
wobei $G=(V,E)$ ein Graph ist und $V'\subseteq V(G)$.
Es gilt $G[V']=(V',E')$ mit $E'=\{(u,v)\in E\mid u\in V'\land v\in V'\}$.
\item Eine Färbung eines Graphen $G=(V,E)$ sei eine Zuordnung $F: V\mapsto \mathbb{N}$. Eine Färbung kann sich zur Laufzeit eines Algorithmusses ändern.
Wenn wir einen Knoten $v$ \grqq färben\grqq\ so ändern wir eigentlich den Wert von $F(v)$.
\item Der Grad $\deg_G(v)$ eines Knoten $v$ ist die Anzahl an von ihm ausgehenden Kanten $|\{(v_1,v_2)\in E(G) | v_1=v\lor v_2=v\}|$
Wir definieren $\delta G=\min\{\deg_G(v)|v\in V(G)\}$
\item Die Nachbarschaft $N(v)$ eines Knoten $v$ innerhalb eines Graphen sind all jene Knoten,
die mit einer Kante mit $v$ verknüpft sind.
\item Die Kantendichte eines Graphen $d(G)$ ist als Angabe zu verstehen, wie viele Kanten im Graphen möglich wären und wie viele davon tatsächlich vorhanden sind. \\
Die Formel hierfür ist: $d(G) = \frac{2*|E|}{|V|(|V|-1)}$, wobei $|E|$ die Anzahl der vorhandenen Kanten ist und $|V|$ die Anzahl der Knoten. \\
\item Ein Independent Set $V'$ (auf deutsch: Stabile Menge) ist eine Untergruppe aller Knoten, die jeweils paarweise nicht durch eine
Kante miteinander verknüpft sind.
\item Ein Co-Graph ist eine Art Graph, die sich mit $3$ Regeln rekursiv konstruieren lässt: \\
\begin{itemize}
  \item Ein Graph mit genau einem Knoten ist ein Co-Graph
  \item Die Vereinigung zweier Co-Graphen ist ein Co-Graph (Knotenmenge ist die Vereinigung beider, Kantenmenge ist die Vereinigung beider)
  \item Die Summe zweier Co-Graphen ist ein Co-Graph (Knotenmenge ist die Vereinigung beider, Kantenmenge ist die Vereinigung beider plus eine Kante von jeweils jedem Knoten der einen Menge und zu jedem Knoten der anderen Menge)
\end{itemize}
\item Ein problematischer Knoten ist ein Knoten mit Nachbarschaft zu Knoten jeder anderen Farbe. \\
Es ist offensichtlich dass, wenn ein Knoten kein problematischer Knoten ist, mindestens eine andere Farbe existiert, in welche er umgefärbt werden kann, \\
sodass eine neue zulässige Färbung entsteht ohne das Nachbarn des Knoten ebenfalls umgefärbt werden müssen.
\end{itemize}

\section{Etablierte Algorithmen}

\subsection{Greedy Algorithmen}

Sei $G=(V,E)$ ein zu färbender Graph.
Wir bestimmen zunächst eine Reihenfolge der Knoten in $V$, wobei $v_i$ der $i$-te Knoten ist.
Der Greedy Algorithmus geht nun folgendermaßen vor:
\begin{itemize}
\item[1.] Sei $i=1$
\item[2.] $F(v_i) \leftarrow \min\{n\in\mathbb{N}|\nexists j < i: F(v_j)=n\land \{v_i, v_j\}\in E\}$
\item[3.] ist $i<|V|$, so $i\leftarrow i+1$ und gehe zurück zu Schritt 1 
\end{itemize}

Je nachdem wie wir die Reihenfolge bilden, erhalten wir unterschiedliche Varianten des Greedy-Algorithmusses.
Wählen wir eine Reihenfolge ohne spezielle Eigenschaften (in der Praxis die Definitionsreihenfolge),
so bezeichnen wir dies als den Standard-greedy, bzw. nur greedy.

Erstellen wir eine Reihenfolge $v_1,v_2,\ldots,v_n$, wobei $v_i$ ein Knoten kleinsten Grades im Graphen $G[\{v_1,\ldots,v_i\}]$ ist, so bezeichnen wir den Algorithmus als greedy-smallest-degree-last oder kurz greedy-max.
Sei $v_i$ analog ein Knoten größten Grades im Graphen $G[\{v_1,\ldots,v_i\}]$, so reden wir von greedy-largest-degree-last oder greedy-min.

Offensichtlich ist eine allgemeine Obergrenze für die Farben die der Greedy Algorithmus verwendet $\Delta G$.
Die Obergrenze kann jedoch auch je nach gewählter Reihenfolge geringer ausfallen. 
So existiert immer eine Reihenfolge um die optimale Färbung mit greedy zu erzeugen.
Sei die Degeneracy von $G$ definiert als\\
$\degeneracy(G)=\max\{\delta G[V']|V'\subseteq V\}$.\\
Mit greedy-max erreichen wir sogar eine Obergrenze von $\degeneracy(G)+1$ Farben.\\
Wir behandeln außerdem den greedy-colors Algorithmus, 
welcher eine Reihenfolge $v_1,v_2,\ldots,v_n$ nutzt,\\ 
wobei $\forall i: i=n\lor
\deg_{G[\{v_1,\ldots,v_i\}]}(v_i)\geq\\
\ \ \max(\{\deg_{G[\{v_1,\ldots,v_{i-1}\}\cup\{j\}]}(v_j)|j\in\{i+1\ldots n\}\})$
Ziel bei diesem Algorithmus ist es, immer Knoten zu färben, welche möglichst viele gefärbte Nachbarn haben.
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/greedy_pic1.png}
  \caption{Ergebnisse der Anwendung einfacher Greedy Varianten}
  \label{fig:greedy1}
\end{figure}
Diese folgengesteuerten Greedyvarianten ermöglichen keine genaueren Abschätzungen.
Es wurde für einzelne Varianten nachgewiesen, dass diese arbiträr schlechte Ergebnisse liefern können.\cite{geedy_mitchem}
Deshalb wollen wir uns auf gemessene Daten beziehen. Diese Daten beschreiben die durchschnittlich gebrauchten Farben, wenn die Algorithmen an Zufallsgraphen, nach Erdős Rényi, angewendet werden.\cite{geedy_erdos_renyi}\\
Man kann an Abbildung \ref{fig:greedy1} erkennen, 
dass greedy-max, bzw. greedy-smallest-last die besten Ergebnisse liefert. Später werden wir diese Ergebnisse auch relativ zu anderen Algorithmen betrachten.

Diese Greedy-Algorithmen können durch einen Farbtauschmechanismus verbessert werden.
wir wenden diesen an, wenn zum Färben eines Knotens $v$ eine neue Farbe verwendet weren würde.
Dabei suchen wir 2 Farben $k_1,k_2$ mit $k_1\neq k_2$, 
sodass der Subgraph $U$ von $G$, 
welcher alle Knoten aus $G$ enthält, 
welche zu dieser Zeit mit $k_1$ oder $k_2$ gefärbt sind, die folgende Eigenschaft erfüllt:\\
$\forall v_1\in U : (v_1\text{ ist benachbart zu }v) \Rightarrow\\
 (\forall v_2 : (F(v_1)\neq F(v_2) \land v_2\text{ ist benachbart zu }v)\Rightarrow\\
  (\text{es existiert auf U kein Pfad zwischen $v_1$ und $v_2$}))$\\
Existieren $k_1,k_2$ welche solche Bedingungen erfüllen, 
so können wir auf einzelnen Zusammenhangskomponenten auf $U$ die beiden Farben tauschen 
bis nur noch eine der beiden Farben mit $v$ benachbart ist.\\
In Abbildung \ref{fig:greedy2} ist eine deutliche Verbesserung der Ergebnisse durch greedy-color-swaps zu erkennen,
dabei wurde der Farbtauschmechanismus auf greedy-max angewendet.
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/greedy_pic2.png}
  \caption{Ergebnisse der Anwendung des greedy-color-swaps Algorithmusses}
  \label{fig:greedy2}
\end{figure}
Im weiteren Verlauf der Arbeit haben wir die Greedyvarianten der Einfachheit halber auf greedy-max und greedy-color-swaps reduziert, 
da diese am Vielversprechendsten sind.

\subsection{Wigdersons Algorithmen} % TODO

Bei den zwei Algorithmen von Wigderson handelt es sich eigentlich um einen Algorithmus und einen Spezialfall dessen. \\
Die Prämisse beider Algorithmen ist, einen schnelleren Algorithmus für Input-Graphen mit hoher Kantendichte zu sein.
Darunter leidet aber im Vergleich zu Greedy-Algorithmen die Zahl der verwendeten Farben. Da weiterhin ein Greedy-Algorithmus verwendet wird,
sobald der Graph nur noch niedrige Knotengrade besitzt, sieht man keine Verbesserung in der $O$-Notation der Komplexität, aber die reale Laufzeit sollte
für jene Graphen mit hoher Kantendichte sinken.

\subsubsection{Wigdersons erster Algorithmus}

Der erste Algorithmus, der Spezialfall, braucht einen Graphen, der garantiert mit $3$ Farben färbbar ist.
Er färbt diesen Graphen in $O(\sqrt{n})$ Farben, wobei $n$ die Anzahl der Knoten im Graphen ist. $O(\sqrt{n})$ bedeutet hier,
dass im schlimmsten Fall $\sqrt{n}$ viele Farben (aufgerundet) verwendet werden, es können aber auch weniger sein. \\
%Bei dem Satz bin ich mir nicht sicher, ob der sein muss oder ob O-Notation einfach in der Begriffserklärung reinkommt
Dieser Algorithmus nutzt aus, dass sich ein $2-$färbbarer Graph immer und mit wenig Aufwand perfekt färben lässt. %Citation needed
Um einen auf jeden Fall $2-$färbbaren Subgraphen zu erhalten, den man färben kann, wird nun zuerst ein Knoten des
Ausgangsgraphen gewählt. Hierbei wird der Knoten mit höchstem Grad ausgewählt. Nun wird dessen Nachbarschaft %Begriffserklärung?
betrachtet. Da der ausgewählte Knoten eine Farbe (o.B.d.A. nennen wir die Farbe $3$) haben muss, die in seiner Nachbarschaft nicht vorkommen kann, muss diese Nachbarschaft
$2-$färbbar sein, da der gesamte Graph $3-$färbbar ist. Also färbt man die Nachbarschaft in $2$ (o.B.d.A. nennen wir diese Farben $1$ und $2$) und entfernt sowohl den Knoten
als auch die Nachbarschaft für die restliche Betrachtung aus dem Ausgangsgraphen aus und kehrt zum ersten Schritt zurück, dem Wählen
des nächsten Knotens mit höchstem Grad. Die Nachbarschaft dessen könnte aber im Ausgangsgraphen mit nun schon
gefärbten und entfernten Knoten benachbart sein, weswegen als Farben für diesen Durchlauf eine ungenutzte Farbe (o.B.d.A. $4$) verwendet wird, sowie die Farbe, die ausgewählte Knoten des letzten Durchlaufs hatte ($3$). \\
Der neue ausgewählte Knoten erhält ebenfalls eine neue Farbe (o.B.d.A. $5$), die dann im nächsten Durchlauf weiter verwendet werden kann.
Dies führt man nun fort, bis es sich mehr lohnt, den Graphen per Greedy-Algorithmus fertig zu färben. 
Dieser Punkt ist erreicht, wenn der höchste Knotengrad im verbleibenden Graphen unter die Grenze von $\sqrt{n}$ fällt. \\
Um nun zu zeigen, wie viele Farben dieser Algorithmus verwendet und welche Komplexität dieser Algorithmus hat, kann man nun rechnen. \\
Für die Anzahl der Farben gilt: Jeder der oben beschriebenen Durchläufe verbraucht $2$ neue Farben und färbt mindestens $\sqrt{n}+1$ Knoten, also $O(\sqrt{n})$.
Deswegen kann es nur weniger als maximal $\sqrt{n}$ Durchläufe geben, bis alle Knoten gefärbt sind oder die Durchläufe abgebrochen werden, weil der maximale Grad zu niedrig wird.
Also verwendet dieser Teil des Algorithmus höchstens $2*\sqrt{n}$ Farben. Da nur noch Knoten mit höchstens Grad $\sqrt{n}-1$ übrig sind, kann der Greedy-Algorithmus
den Rest des Graphen immer in $\sqrt{n}$ Farben färben. So erhält man ein Ergebnis von maximal $3*\sqrt{n}$ Farben. \\
Für die Komplexität des Algorithmus gilt: Jeder der oben beschriebenen Durchläufe iteriert über alle Knoten, um den mit dem größten Grad zu finden $(O(n))$,
noch einmal, um die Nachbarschaft vom Knoten zu ermitteln $(auch \space O(n))$ %oder auch nicht, weil sich das in der NetworkX Dokumentation nicht herausfinden lässt aaaaaaaaaaaaaaaah
und hat wie in der Rechnung zur Farbanzahl schon gezeigt $\sqrt{n}$ Durchläufe maximal $O(\sqrt{n})$.
Dieser Teil des Algorithmus ist also in der Komplexitätsklasse $O(n*\sqrt{n})$. \\
Der Greedy-Algorithmus hat die Komplexität von $O(n+m)$ oder $O(n^2)$, je nachdem wie NetworkX im Hintergrund die Adjacency abspeichert... %Bro ist das dumm ey. Da steht nicht genau, wie der Befehl G.neighbors funktioniert, den wir die ganze Zeit verwendet haben.
wobei das $m$ für die Anzahl der Kanten steht. Laut Wigderson selbst sollte die Komplexität des Algorithmus $O(3*(n+m))$ sein. Vielleicht wenn der obere Teil des Algorithmus nicht $O(n*\sqrt{n})$ ist sondern $O(n)$. Aber da bin ich mir nicht ganz sicher gerade.

\subsubsection{Wigdersons zweiter Algorithmus}

Der zweite Algorithmus ist eine verallgemeinerte Variante, die funktioniert, wenn die Färbungszahl des gegebenen Graphen bekannt ist.
Er benutzt dabei $k*n^{1-\frac{1}{k-1}}$ Farben maximal, wobei $k$ die Färbungszahl und $n$ die Anzahl der Knoten ist. \\
Der Algorithmus verwendet die gleiche Eigenschaft, dass ein $2-$färbbarer Graph simpel zu färben ist.
Dazu wird wie im obigen Algorithmus beschrieben, der Knoten mit höchstem Grad ausgewählt und auf dessen Nachbarschaft geschaut. Da die Färbungszahl hier wahrscheinlich noch nicht $3$ beträgt, lässt sich diese Nachbarschaft nicht mit $2$ Farben färben, aber dafür mit $k-1$ Farben. Sollte dies immer noch nicht gleich $3$ sein, so wird in dieser Nachbarschaft erneut der Knoten mit höchstem Grad ausgesucht und dann in diesem Subgraphen dessen Nachbarschaft angeschaut. Sie kann nun sicher mit $k-2$ Farben gefärbt werden. Sollte dies nun gleich $3$ ergeben, wird noch einmal so vorgegangen wie im ersten Algorithmus und so dieser Subgraph gefärbt. \\
Auch wie im anderen Algorithmus gibt es ein Abbruchkriterium, wann sich stattdessen der Greedy-Ansatz mehr lohnt. Dieses ist erreicht, wenn der amximale Grad im betrachteten (Sub-)Graphen kleiner ist als $k*n^{\frac{1}{k-1}}$, die gleiche Gleichung wie die Maximalzahl an Farben im Graphen.
Dieser Algorithmus hat laut Wigderson eine Laufzeitkomplexitätsklasse von $O(k(n+m))$, wobei $k$ die Färbungszahl, $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten ist.

\subsection{Johnsons Algorithmus} % TODO

Dieser Algorithmus unterteilt den Graphen auf eine andere Art.
Hier wird ein anderes Konzept der Graphentheorie verwendet, nämlich die Independent Sets. \\
Independent Sets haben die Eigenschaft,dass ihre Knoten nicht miteinander verknüpft sind 
und somit im Kontext Graphenfärbung alle die gleiche Farbe haben können.
Dies wird vom Algorithmus folgendermaßen verwendet: \\
Da das Ermitteln des größten Independent Sets innerhalb eines Graphen auch ein NP-schweres Problem ist,
wird im Folgenden immer ein möglichst großes Independent Set gesucht,und zwar wie folgt: \\
Man startet mit dem Knoten $v$ mit kleinstem Grad.
Dies kann mehrdeutig sein, dann wählt man z.B. per Zufall einen aus.
Dieser ist nun der erste Knoten des Independent Sets.
Das bedeutet, dass seine Nachbarschaft nicht Teil dessen wird und aus der Betrachtung entfernt wird, 
es entsteht ein Subgraph $G' = G - N[v]$
Dann wird in diesem der Knoten mit kleinstem Grad ermittelt und ins Independent Set hinzugefügt 
und mitsamt Nachbarschaft aus dem Graphen entfernt. 
Dies macht man so lange, bis der komplette Graph abgedeckt wurde und bildet so ein möglichst großes Independent Set, 
was dann für den weiteren Algorithmus verwendet wird. \\
Im Graphen wird zunächst auf diese Weise das größtmögliche Independent Set ermittelt. \\
Das ausgewählte Set wird in einer neuen Farbe gefärbt und für den Rest der Färbung nicht betrachtet. \\
Dann wird im restlichen Subgraphen wieder das größte Independent Set bestimmt und gefärbt, solange bis der gesamte Graph gefärbt wurde.
So färbt man einen Graphen, der theoretisch $k$-färbbar ist in $O(\frac{n}{log_k(n)})$ Farben.

\subsection{Berger Rompel Algorithmus}
In ihrem Paper schlagen Berger und Rompel einen Algorithmus $A_\alpha(k,G)$ vor, welcher einen Graphen in $2*n/\alpha (\log_k n)^2 + O(n/(\log_k n)^3)$ Farben färben kann, wobei $k$ die optimale Färbungszahl für einen Graphen ist und $n=|G|$.\cite{berger_rompel}.
Dieser baut auf dem Algorithmus von Johnson auf und erweitert diesen, indem
mehrere Knoten mit möglichst kleiner Nachbarschaft, statt einzelnen Knoten, zu den Independent Sets hinzugefügt werden.
Theoretisch wird also eine reine Verbesserung erzielt, da im schlimmsten Fall, dieselben Knoten wie bei Johnson in das Set eingefügt werden.

\section{Ergebnisse zu den etablierten Algorithmen}

Betrachtet man den normalen greedy-Algorithmus als eine Messleiste, dann fällt auf, dass sich die Algorithmen in zwei Gruppen unterteilen lassen: \\
Die, die bessere theoretische Obergrenzen für verwendete Farben haben und die, die durchschnittlich bessere Färbungen erzeugen.\\
In dem Experiment, welches in Abbildung \ref{fig:generic2} gezeigt wird, wurden die Algorithmen an Graphen, mit konstruierter Obergrenze der Färbungszahl, angewendet. 
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/generic_pic2.png}
  \caption{Vergleich der etablierten Algorithmen (Farben)}
  \label{fig:generic2}
\end{figure}
Hier fällt auf, dass die verwendeten Farben nicht die theoretischen Obergrenzen widerspiegeln. Die greedy Algorithmen, erziehlten die besten Ergebnisse. Besonders greedy-color-swaps überzeugt.
Allerdings ist der Algorithmus auch viel aufwändiger, vor allem bei Graphen mit hoher Kantendichte \\
Gerade die Wigderson-Algorithmen benutzen viele Farben, weil sie Farben nicht wieder verwenden, obwohl es möglich wäre. \\
Möglicherweise würde der Johnson-Algorithmus bessere Ergebnisse liefern, wenn man einen komplexeren Algorithmus zum Finden der Independent Sets verwenden würde,
das würde dann aber auch wieder die Laufzeit und Komplexität verschlechtern. Diese These wird unterstützt davon, dass der Algorithmus auf Co-Graphen quasi die gleichen Färbungszahlen erhält wie die greedy-Algorithmen.\\
Entgegen unserer Erwartung benutzt der Berger Rompel Algorithmus mehr Farben als Johnson. Wir haben diese Beobachtung mehrfach als Implementierungsfehler abgetan, jedoch ist es uns nie gelungen diesen Fehler zu beheben.
Erstaunlich ist dieses Ergebnis auch im Hinblick der Laufzeit, welche in Abbildung \ref{fig:generic1} abgebildet ist,
da der greedy-max Algorithmen mit den 2. Besten Farbergebnissen, eher eine bessere Laufzeit aufweißt, als die anderen Algorithmen.
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/generic_pic1.png}
  \caption{Vergleich der etablierten Algorithmen (Laufzeit)}
  \label{fig:generic1}
\end{figure}
\section{Eigens produzierte Algorithmen} % TODO
\subsection{Merging Algorithmus}
Bei der Überlegung, welche Ansätze zur Entwicklung eines eigenen Solvers sinnvoll wären,
kam die Idee auf, das bekannte Konzept des Divide-and-Conquer zu nutzen.\\
Idee dabei ist, die Färbung für einen Graphen $G$ zu finden, 
indem zunächst ein Schnitt $S\subseteq V(G)$ gebildet wird 
und der Algorithmus rekursiv auf die ind. Subgraphen 
$G[S]$ und $G[V(G)\setminus] S$ angewendet wird. 
Kleine Graphen können dann sogar optimal gelöst werden. 
Problem jedoch ist, dass an den Kanten, 
welche in keiner der ind. Subgraphen enthalten sind,
Konflikte entstehen können. Diese müssen durch eine besondere Operation entfernt werden, 
welche wir nun als Vereinigung bezeichnen.\par

Wir können nun in der Wahl des Schnittes und dem Algorithmus zur Vereinigung variieren.\\
In unserer Arbeit haben wir 2 Varianten analysiert. Wir nennen sie merge-trivial und merge-recolor.
Dabei nutzen beide folgenden Algorithmus um einen Schnitt $S\subseteq V(G)$ zu bilden:
\begin{itemize}
\item[1.] Führe den folgenden Algorithmus für alle Zusammenhangskomponenten von $G$ getrennt aus
\item[2.] Wähle einen zufälligen Knoten $u\in V(G)$
\item[3.] Berechne zu jedem Knoten in $n\in V(G)$ die Distanz $d_u(n)$ zu $u$ mithilfe einer Breitensuche
F\item[4.] Wähle einen Knoten mit maximaler Distanz zu $u$, bezeichne ihn als $v$
\item[5.] Berechne zu jedem Knoten in $n\in V(G)$ auch die Distanz $d_v(n)$ zu $v$
\item[6.] Für jeden Knoten $n\in V(G)$: Füge $n$ zu $S$ hinzu, falls $d_u(n)<d_v(n)$; Falls $d_u(n)=d_v(n)$ füge $n$ mit einer Wahrscheinlichkeit von 50\% zu $S$ hinzu
\end{itemize}

Der merge-trivial Algorithmus nutzt eine triviale Vereinigungsstrategie. 
Wenn zur Färbung von $G[S]$ die Farben $\{1,2,...,i\}$ benutzt wurden, 
werden für die Färbung von $G[V(G)\setminus S]$ nur Farben $\{i+1,i+2,...,k\}$ verwendet.\\

Der Algorithmus liefert vergleichsweise schlechte Ergebnisse, 
da lediglich im Basisfall eine Verbesserung gegenüber der trivialen Färbung erziehlt werden kann.
Angenommen der Algorithmus färbt ab einer Anzahl von $m$ oder weniger Knoten optimal
und $k$ sei die optimale Färbungszahl von $G$, so kommt man auf eine untere Grenze von 
$k*2^{log_2(|V(G)|)-log_2(m)}$ bzw. $k*\frac{|V(G)|}{m}$ Farben, vorausgesetzt, dass $m\geq k$.\par

Der merge-recolor Algorithmus nutzt stattdessen einen aufwendigeren Vereinigungsalgorithmus:\\
Wir bezeichnen hierbei den Subgraphen $G[S]$ als $A$ und den Subgraphen $G[V(G)\setminus S]$ als $B$
\begin{itemize}
\item[1.] Benenne Farben in $B$ um, bis keine Farbe sowohl in $A$ als auch in $B$ verwendet wird.
\item[2.] Konstruiere einen Graphen $G'=(V',E')$, $V'$ sei die Menger verwendeter Farben
\item[3.] $E'$ sei die Menge aller Paare aus Farben, welche nicht durch eine Kante in $G$ miteinander verbunden sind. \\Hierzu sollte nur die Menge der Kanten $E(G)\setminus (E(A)\cup E(B))$ betrachtet werden.
\item[4.] Berechne ein maximales Matching $M$ auf $G'$, also eine möglichst größe Menge von Kanten, wobei keine 2 Kanten denselben Knoten enthalten.
\item[5.] Für jede Kante $(u,v)\in M$, färbe alle Knoten der Farbe $u$, stattdessen mit der Farbe $v$.
\end{itemize}

Zusätzlich behandeln wir eine Alternative Version, merge-recolor-bf, welche im Basisfall tatsächlich eine optimale Lösung (hier per \textbf{b}rute-\textbf{f}orce) findet.
Der Standardfall merge-recolor greift lediglich auf den greedy-max Algorithmus zu.

\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/merger_pic1.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit Greedy bei Graphen mit 50 Knoten}
  \label{fig:merge1}
\end{figure}

Im Vergleich zu den besseren Varianten der Greedy Algorithmen schneiden die Merging Algorithmen unterschiedlich ab. Wie in Abbildung \ref{fig:merge1} zu sehen ist, scheidet der merge-trivial Algorithmus sehr schlecht ab.
Vielversprechender sind die merge-recolor und merge-recolor-bf Algorithmen, welche bessere Ergebnisse als merge-trivial erzielen können, jedoch immernoch schlechter sind als greedy-max. Untereinander unterscheiden sich die Ergebnisse der bisherigen merge-recolor Varianten kaum.

\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/merger_pic2.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit Greedy bei Graphen mit 300 Knoten}
  \label{fig:merge2}
\end{figure}

Die Unterschiede werden bei Graphen mit 300 Knoten noch deutlicher (siehe Abb. \ref{fig:merge2}).
Um die Ergebnisse des merge Algorithmusses zu verbessern haben wir im Weiteren versucht, 
die Farben, welche bei der Vereinigung nicht zusammengefasst werden können,
zu entfärben und ihre Knoten mittels des in greedy-color-swaps verwendeten Verfahren neu zu färben.
Praktisch heißt dies, dass wir den Vereinigungsschritt um eine Anwendung von color-swaps erweitern.
Dies tun wir wie folgt:

\begin{itemize}
\item[1.] Benenne Farben in $B$ um, bis keine Farbe sowohl in $A$ als auch in $B$ verwendet wird.
\item[2.] Konstruiere einen Graphen $G'=(V',E')$, $V'$ sei die Menger verwendeter Farben
\item[3.] $E'$ sei die Menge aller Paare aus Farben, welche nicht durch eine Kante in $G$ miteinander verbunden sind. \\Hierzu sollte nur die Menge der Kanten $E(G)\setminus (E(A)\cup E(B))$ betrachtet werden.
\item[4.] Berechne ein maximales Matching $M$ auf $G'$, also eine möglichst größe Menge von Kanten, wobei keine 2 Kanten denselben Knoten enthalten.
\item[5.] Für jede Kante $(u,v)\in M$, färbe alle Knoten der Farbe $u$, stattdessen mit der Farbe $v$.
\item[6.] Für jeden Knoten $u\in M$, wobei $\neg \exists e\in M : u\in e$, entfärbe alle Knoten mit Farbe $u$.
\item[7.] Wähle einen ungefärbten Knoten $x$. Existiert keiner, so springe zu 10.
\item[8.] Finde 2 Knoten $y,z$ aus der Nachbarschaft von $x$, diese seien mit den Farben $F(y)$ und $F(z)$ gefärbt, wobei $F(y)\neq F(z)$.
Außerdem lasse sich die Zusammenhangskomponente aus Knoten $\{v\in G | F(v)=F(y) \lor F(v)=F(z)\}$ um $z$ so umfärben, dass im Endeffekt $F(y)=F(z)$ gilt.
\item[9.] Lässt sich 8. durchführen, so Färbe $z$ um und gebe $x$ die alte Farbe von $z$, andernfalls gebe $x$ die kleinste, nicht in seiner Nachbarschaft verwendete, Farbe.
\item[10.] Solange noch ungefärbte Knoten existieren gehe zurück zu 7.
\end{itemize}

Diesen Algorithmus bezeichnen wir nun als greedy-recolor-color-swaps.
Er weißt deutlich bessere Ergebnisse auf (siehe Abb. \ref{fig:merge3}), jedoch werden von greedy-color-swaps dennoch bessere Ergebnisse erzielt.
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/merger_pic3.png}
  \caption{Vergleich der beschriebenen Merger Algorithmen mit dem merge-recolor-color-swaps Ansatz}
  \label{fig:merge3}
\end{figure}
Besonders fällt dies auf, wenn wir statt den verwendeten Farben die Laufzeit betrachten. Die verwendeten Farben liegen auf ähnlichem Level,
aber die Laufzeit ist bei dem merge-recolor-color-swaps Verfahren deutlich schlechter (siehe Abb. \ref{fig:merge4}).\\
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/merger_pic4.png}
  \caption{Vergleich der Laufzeit zwischen greedy und merge mit color swaps}
  \label{fig:merge4}
\end{figure}
Merge-recolor, welches von Farben her eher mit greedy-max vergleichbar ist, hatte auf unseren Testdaten ebenfalls eine schlechtere Laufzeit (siehe Abb.\ref{fig:merge5}).
\begin{figure}
  \includegraphics[width=\stdwidth]{diagrams/merger_pic5.png}
  \caption{Vergleich der Laufzeit zwischen greedy und merge ohne color swaps}
  \label{fig:merge5}
\end{figure}

Wollte man den merge Ansatz weiter verfolgen wollen, bleibt zu analysieren, warum der bisherige Algorithmus mehr Farben braucht als greedy.
Ein essenzieller Angriffspunkt bleibt die Wahl des Schnittes die wir zunächst vorgestellt haben und nicht variiert haben.
Wir können diese Wahl so abwandeln, dass die Möglichkeit für Konflikte zwischen Farben pro Vereinigung minimiert wird.
Ein Ansatz hierfür den Knoten mit der geringsten Nachbarschaft abzutrennen und den Algorithmus auf den Knoten sowie den Restgraphen anzuwenden.
Dies gleicht jedoch weitesgehend dem Verhalten von greedy-min.

Wir beenden diesen Ansatz mit dem Fazit, dass sich mit diesem Verfahren für uns keine großen Fortschritte ergeben,
da die Abweichung zu bisherigen Algorithmen hier eher einen Nachteil dargestellt hat.
Stattdessen wollen wir mit einem Verfahren weitermachen, welches bisherige Algorithmen versucht zu erweitern, anstatt sie zu ersetzen.

\subsection{Elim}

Elim ist der einfachste Algorithmus zur Verbesserung einer gegebenen Färbung. \\

Durch das Prüfen auf problematische Knoten können wir unnötige Farben leicht identifizieren und dann eliminieren.

Für alle Farben wird ausgeführt: \\
\begin{itemize}
\item[1.] Prüfe Farbe x auf das Vorhandensein von problematischen Knoten.
\item[2.] Wenn problematische Knoten vorhanden sind, breche ab und fahre mit der nächsten Farbe fort.
\item[3.] Ansonsten; färbe alle vorhandenen Knoten in zulässige andere Farben um, sodass keiner mehr Farbe x hat.
\item[4.] Fahre mit der nächsten Farbe fort.
\end{itemize}

Elim verbessert vor allem Färbungen stark, welche durch Algorithmen erzeugt werden die oft Farben verlassen, wie die Wigderson-Algorithmen. \\
Auch auf Färbungen von Greedy konnten leichte Verbesserungen festgestellt werden. \\
Zudem ist der Rechenaufwand im Vergleich zum Aufwand der hier untersuchten anderen Algorithmen minimal. Im Worst case bei $k$ Farben
in der Vorfärbung braucht der Algorithmus zwar $O(k*n)$ Schritte, allerdings setzt das eine absolut inkompetente Vorfärbung voraus. \\
Da meist nur einige bis gar keine Farben eingespart werden können, ist die Komplexität im Durchschnittsfall jedoch signifikant näher an $n$ als an $k*n$

\subsection{Make-Better Algorithmus} %muss glaub ich weg 

Der Make-Better Algorythmus ist einer Erweiterung der Elim Funktion. \\
Zunächst nutzt Make-Better Elim um alle Farben ohne problematische Knoten zu elemienieren. \\
Daraufhin betrachtet der Algorythmus jede Farbe erneut und versucht, durch das Umfärben von Zusammenhangs-Komponenten, problematische Knoten aus Farb-Mängen zu entfernen.
Gelingt es alle problematischen Knoten aus einer Farbe zu entfernen so wird erneut Elim angewant um die Farbe vollständig zu elimienieren. \\



\subsection{Umfärben von Zusammenhangskomponenten}

Der Elim-Algorithmus kommt allerdings schnell an seine Grenzen wenn es darum geht, was er umfärben kann. Es gibt unter Umständen die Möglichkeit,
Knoten von problematisch zu unproblematisch zu konvertieren, wenn man andere Knoten umfärbt. Deswegen funktioniert dieser Algorithmus wie folgt: \\

\begin{itemize}
  \item Versuche, Elim auf Graphenfärbung anzuwenden
  \item Wenn es für alle Farben fehlschlägt, identifiziere alle problematischen Knoten einer Farbe und Färbe ihre Zusammenhangscomponente um.
  \item Versuche erneut, Elim auf Graphenfärbung anzuwenden
\end{itemize}

Dieser Prozess kann auf verschiedenste Arten und Weisen durchgeführt werden, unsere Implementation hat eine zufällige Anzahl an unproblematischen Knoten umgefärbt ohne größeres System dahinter.
Dies war vor allem, um die Laufzeit nicht zu sehr in die Höhe zu treiben. So liegt sie nämlich noch in $O(n)$, zuzüglich des Aufwands von Elim, also technisch gesehen $O(k*n)$.

\subsection{Aus 3 Mach 2}

Dieser Algorithmus hat ebenfalls als Ansatz, eine bestehende Färbung zu verbessern. Hierbei wird auch auf ein bekanntes Konzept
zurückgegriffen, was bereits von Wigdersons Algorithmen verwendet wurde: Es lässt sich mit linearer Komplexität herausfinden,
ob ein Graph 2-färbbar ist. Der Algorithmus funktioniert dann auf die folgende Weise: \\

\begin{itemize}
  \item Bilde des Subgraphen $G'$ mit nur Knoten mit den Farben $a$, $b$ und $c$ und entfärbe diese in $G'$
  \item Versuche, diesen Graphen nur mit $2$ Farben ($a$ und $b$) zu färben
  \item Falls möglich, übernehme die Färbung im Ausgangsgraphen und entferne Farbe $c$ aus der Farbliste
  \item Falls nicht möglich, probiere mit anderen Farben $a'$, $b'$ und $c'$
\end{itemize}

Der Algorithmus geht dabei bei $k$ Ausgangsfarben maximal $k*(k-1)*(k-2)$ mal durch den Graphen und hat somit eine Komplexität von $O(k^3)*n$.
Dies ist meist signifikanter als das, was der Algorithmus braucht, der die Färbung erzeugt, z. B. $O(n+m)$ bei Greedy. \\
%weiß nicht, obs ne schöne Formel für Farbeinsparung gibt, wahrscheinlich nicht

\section{Ergebnisse zu den eigenen Algorithmen} % TODO

%zu merging weiß ich nicht genug
Der Ansatz von Elim, bereits vorhandene Lösungen zu verbessern, stellte sich als deutlich erfolgreicher heraus. Als erstes hatten wir diesen Algorithmus nur auf die Ergebnisse von greedy angewandt. \\
Dann haben wir ausprobiert, was passiert, wenn man andere Vorfärbungen verwendet und haben auch dort Verbesserungen festgestellt. Selbst beim Algorithmus mit den bisher besten Ergebnissen, nämlich greedy-color-swaps
ließ sich in seltenen Fällen noch eine Verbesserung feststellen. Dazu kommt, dass dieser Algorithmus vergleichsweise kaum Laufzeit hat, sodass man ihn problemlos auf alle möglichen Färbungs-Algorithmen anwenden konnte. \\
Vor allem bei den Ergebnissen der Wigderson-Algorithmen konnte die Färbungszahl ein gutes Stück nach unten korrigiert werden, da, wie bereits angesprochen, dort Farben oft sehr schnell nicht mehr weiter verwendet werden. \\
Insgesamt deutete sich aber an: je besser die Ausgangsfärbung, desto besser das Ergebnis von Elim.  
Die Erweiterung von Elim auf das Umfärben von Zusammenhangskomponenten hat da einen gewissen Nachteil: Die Laufzeit ist um ein Vielfaches länger als bei Elim. \\ %oder? ich weiß nicht, was der letzte Stand da ist. - ja,
Sie liefert vereinzelt noch Verbesserungen gegenüber Elim, jedoch sind diese stark von der speziefischen Graphstruktur abhänging, wie Ringe. Allerdings ist durch Elim schon eine fielzahl einfacher Fälle abgedeckt sodas die Erweiterung zuweilen keine Verbesserung vonehmen kann. \\
Der andere Ansatz des Aus-3-Mach-2-Algorithmus hat etwas andere Ergebnisse geliefert als gedacht. Im Durchschnitt lieferte der Algorithmus etwas schlechtere Färbungszahlen als die guten Algorithmen wie greedy-color-swap mit Elim.
Allerdings waren die niedrigsten und höchsten Werte sehr weit auseinander. Der Durchschnitt könnte also durch Ausreißer nach oben geschossen sein. 
Das bedeutet jedoch auch, dass der Algorithmus nicht so verlässlich ist wie beispielsweise Elim. Vor allem kommt aber noch dazu, dass der Algorithmus viel mehr Laufzeit benötigt, was ihn leider endgültig disqualifiziert. \\

\section{Zusammenfassung und Fazit} % TODO

Im Gesamten bleibt zu sagen, dass die etablierten Algorithmen vor allem Fortschritte in der Laufzeitoptimierung waren.
Die greedy-Algorithmen haben teils deutlich kleinere Färbungszahlen geliefert. Vor allem die Färbungszahlen, die greedy-color-swaps geliefert hat, waren weit unter dem was wir erwarteten. \\
Außerdem war überraschend, wie gut Elim die gegebenen Färbungen zuweilen noch verbessern konnte. Es war uns jedoch nicht möglich eine Formel zu finden welche die Verbesserung der Färbungszahl durch Elim beschreibt. In unseren Tests konnten wir jedoch beobachten das Elim gerade schlechtere Färbungen noch stark verbessern kann. \\

Das Fazit unserer Ergebnisse ist das sollte man fiele Graphen schnell färben wollen ist ein einfacherer Greedy-Algorythmus und eine darauf folgende Anwendung von Elim am efektievsten. \\
Sollte Laufzeit oder Rechenkraft von weniger interesse sein kann statt greedy, greedy-color-swapps angewendet werden um noch bessere Färbungen zu erhalten.

\bibliographystyle{plain}
\bibliography{Quellen}
\end{document}
