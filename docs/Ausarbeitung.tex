\documentclass[11pt]{article}

\usepackage{blindtext}
\usepackage{titlesec}
\usepackage[hidelinks]{hyperref}

% \subsection{References for the prototype}
% 
% Wenn wir irgendwas referenzieren wollen, vor allem andere Algorithmen. Sollten wir die Quelle in Quellen.bib eintragen und mit \cite{Quelle} zitieren
% Das System beruht auf Bibtex, das muss also runtergeladen werden
% 
% \cite{berger_rompel}

\title{Analyse und Verbesserung bestehender Algorithmen zur Lösung des Graphfärbeproblems}
\author{Menschen} % TODO

\renewcommand*\contentsname{Inhaltsverzeichnis} % Hier kann der Name des Inhaltsverzeichnisses verändert werden

\begin{document}
\maketitle

\tableofcontents

\section{Kurzfassung} % Was haben wir gemacht, ein Absatz
\section{Begriffsklärung} % TODO, laufend aktualisieren, wenn ein neuer Begriff verwendet wurde
\section{Etablierte Algorithmen}
\subsection{Greedy Algorithmen} % TODO
\subsection{Wigdersons Algorithmen} % TODO

Bei den zwei Algorithmen von Wigderson handelt es sich eigentlich um einen Algorithmus und einen Spezialfall dessen.

\subsubsection{Wigdersons erster Algorithmus}

Der erste Algorithmus, der Spezialfall, braucht einen Graphen, der garantiert mit $3$ Farben färbbar ist.
Er färbt diesen Graphen in $O(\sqrt{n})$ Farben, wobei $n$ die Anzahl der Knoten im Graphen ist. $O(\sqrt{n})$ bedeutet hier,
dass im schlimmsten Fall $\sqrt{n}$ viele Farben (aufgerundet) verwendet werden, es können aber auch weniger sein. \\
%Bei dem Satz bin ich mir nicht sicher, ob der sein muss oder ob O-Notation einfach in der Begriffserklärung reinkommt
Dieser Algorithmus nutzt aus, dass sich ein $2-$färbbarer Graph immer und mit wenig Aufwand perfekt färben lässt. %Citation needed
Um einen auf jeden Fall $2-$färbbaren Subgraphen zu erhalten, den man färben kann, wird nun zuerst ein Knoten des
Ausgangsgraphen gewählt. Hierbei wird der Knoten mit höchstem Grad ausgewählt. Nun wird dessen Nachbarschaft %Begriffserklärung?
betrachtet. Da der ausgewählte Knoten eine Farbe (o.B.d.A. nennen wir die Farbe $3$) haben muss, die in seiner Nachbarschaft nicht vorkommen kann, muss diese Nachbarschaft
$2-$färbbar sein, da der gesamte Graph $3-$färbbar ist. Also färbt man die Nachbarschaft in $2$ (o.B.d.A. nennen wir diese Farben $1$ und $2$) und entfernt sowohl den Knoten
als auch die Nachbarschaft für die restliche Betrachtung aus dem Ausgangsgraphen aus und kehrt zum ersten Schritt zurück, dem Wählen
des nächsten Knotens mit höchstem Grad. Die Nachbarschaft dessen könnte aber im Ausgangsgraphen mit nun schon
gefärbten und entfernten Knoten benachbart sein, weswegen als Farben für diesen Durchlauf eine ungenutzte Farbe (o.B.d.A. $4$) verwendet wird, sowie die Farbe, die ausgewählte Knoten des letzten Durchlaufs hatte ($3$). \\
Der neue ausgewählte Knoten erhält ebenfalls eine neue Farbe (o.B.d.A. $5$), die dann im nächsten Durchlauf weiter verwendet werden kann.
Dies führt man nun fort, bis es sich mehr lohnt, den Graphen per Greedy-Algorithmus fertig zu färben. 
Dieser Punkt ist erreicht, wenn der höchste Knotengrad im verbleibenden Graphen unter die Grenze von $\sqrt{n}$ fällt. \\
Um nun zu zeigen, wie viele Farben dieser Algorithmus verwendet und welche Komplexität dieser Algorithmus hat, kann man nun rechnen. \\
Für die Anzahl der Farben gilt: Jeder der oben beschriebenen Durchläufe verbraucht $2$ neue Farben und färbt mindestens $\sqrt{n}+1$ Knoten, also $O(\sqrt{n})$.
Deswegen kann es nur weniger als maximal $\sqrt{n}$ Durchläufe geben, bis alle Knoten gefärbt sind oder die Durchläufe abgebrochen werden, weil der maximale Grad zu niedrig wird.
Also verwendet dieser Teil des Algorithmus höchstens $2*\sqrt{n}$ Farben. Da nur noch Knoten mit höchstens Grad $\sqrt{n}-1$ übrig sind, kann der Greedy-Algorithmus
den Rest des Graphen immer in $\sqrt{n}$ Farben färben. So erhält man ein Ergebnis von maximal $3*\sqrt{n}$ Farben. \\
Für die Komplexität des Algorithmus gilt: Jeder der oben beschriebenen Durchläufe iteriert über alle Knoten, um den mit dem größten Grad zu finden $(O(n))$,
noch einmal, um die Nachbarschaft vom Knoten zu ermitteln $(auch \space O(n))$ %oder auch nicht, weil sich das in der NetworkX Dokumentation nicht herausfinden lässt aaaaaaaaaaaaaaaah
und hat wie in der Rechnung zur Farbanzahl schon gezeigt $\sqrt{n}$ Durchläufe maximal $O(\sqrt{n})$.
Dieser Teil des Algorithmus ist also in der Komplexitätsklasse $O(n*\sqrt{n})$. \\
Der Greedy-Algorithmus hat die Komplexität von $O(n+m)$ oder $O(n^2)$, je nachdem wie NetworkX im Hintergrund die Adjacency abspeichert... %Bro ist das dumm ey. Da steht nicht genau, wie der Befehl G.neighbors funktioniert, den wir die ganze Zeit verwendet haben.
wobei das $m$ für die Anzahl der Kanten steht. Laut Wigderson selbst sollte die Komplexität des Algorithmus $O(3*(n+m))$ sein. Vielleicht wenn der obere Teil des Algorithmus nicht $O(n*\sqrt{n})$ ist sondern $O(n)$. Aber da bin ich mir nicht ganz sicher gerade.

\subsubsection{Wigdersons zweiter Algorithmus}

Der zweite Algorithmus ist eine verallgemeinerte Variante, die funktioniert, wenn die Färbungszahl des gegebenen Graphen bekannt ist.
Er benutzt dabei $k*n^{1-\frac{1}{k-1}}$ Farben maximal, wobei $k$ die Färbungszahl und $n$ die Anzahl der Knoten ist. \\
Der Algorithmus verwendet die gleiche Eigenschaft, dass ein $2-$färbbarer Graph simpel zu färben ist.
Dazu wird wie im obigen Algorithmus beschrieben, der Knoten mit höchstem Grad ausgewählt und auf dessen Nachbarschaft geschaut. Da die Färbungszahl hier wahrscheinlich noch nicht $3$ beträgt, lässt sich diese Nachbarschaft nicht mit $2$ Farben färben, aber dafür mit $k-1$ Farben. Sollte dies immer noch nicht gleich $3$ sein, so wird in dieser Nachbarschaft erneut der Knoten mit höchstem Grad ausgesucht und dann in diesem Subgraphen dessen Nachbarschaft angeschaut. Sie kann nun sicher mit $k-2$ Farben gefärbt werden. Sollte dies nun gleich $3$ ergeben, wird noch einmal so vorgegangen wie im ersten Algorithmus und so dieser Subgraph gefärbt. \\
Auch wie im anderen Algorithmus gibt es ein Abbruchkriterium, wann sich stattdessen der Greedy-Ansatz mehr lohnt. Dieses ist erreicht, wenn der amximale Grad im betrachteten (Sub-)Graphen kleiner ist als $k*n^{\frac{1}{k-1}}$, die gleiche Gleichung wie die Maximalzahl an Farben im Graphen.
Dieser Algorithmus hat laut Wigderson eine Laufzeitkomplexitätsklasse von $O(k(n+m))$, wobei $k$ die Färbungszahl, $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten ist.

\subsection{Johnsons Algorithmus} % TODO
\subsection{Berger Rompel Algorithmus} % TODO

Der Algorithmus von Berger Rompel
baut auf der Idee von Johnsons und Wigderson auf
und verbessert diese um einige Punkte.
\cite{berger_rompel}

\section{Ergebnisse zu den etablierten Algorithmen} % TODO
\section{Eigens produzierte Algorithmen} % TODO

\subsection{Make-Better Algorithmus}

Der Ansatz für diesen Algorithmus war es, eine schon fertige Färbung eines Graphen zu nehmen und versuche, diese zu verbessern. \\
Um dies durchzuführen, werden die Knoten als Farbgruppen betrachtet. Dann schaut man in jeder Farbgruppe, ob man nicht die einzelnen Knoten in eine andere Farbe umfärben kann. \\
Das kann man immer, wenn ein Knoten keine Verbindung zu mindestens einer anderen Farbe hat. Findet man so eine Farbgruppe, aus der man alle Knoten umfärben kann, 
macht der Algorithmus dies und entfernt somit eine ganze Farbe aus der Färbung des Graphen. \\
Dies kann man so lange wiederholen, bis sich keine Farbe mehr entfernen lässt.

\section{Ergebnisse zu den eigenen Algorithmen} % TODO
\section{Zusammenfassung und Fazit} % TODO

\bibliographystyle{plain}
\bibliography{Quellen}
\end{document}
